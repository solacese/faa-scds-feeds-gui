{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../VirtualList.svelte",
    "../ConnectionSpinner.svelte"
  ],
  "sourcesContent": [
    "<script>function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { onMount, tick } from 'svelte'; // props\n\nexport var items;\nexport var height = '100%';\nexport var itemHeight = undefined;\nvar foo; // read-only, but visible to consumers via bind:start\n\nexport var start = 0;\nexport var end = 0; // local state\n\nvar height_map = [];\nvar rows;\nvar viewport;\nvar contents;\nvar viewport_height = 0;\nvar visible;\nvar mounted;\nvar top = 0;\nvar bottom = 0;\nvar average_height;\n\n$: visible = items.slice(start, end).map((data, i) => {\n  return {\n    index: i + start,\n    data\n  };\n}); // whenever `items` changes, invalidate the current heightmap\n\n\n$: if (mounted) refresh(items, viewport_height, itemHeight);\n\nfunction refresh(_x, _x2, _x3) {\n  return _refresh.apply(this, arguments);\n}\n\nfunction _refresh() {\n  _refresh = _asyncToGenerator(function* (items, viewport_height, itemHeight) {\n    var {\n      scrollTop\n    } = viewport;\n    yield tick(); // wait until the DOM is up to date\n\n    var content_height = top - scrollTop;\n    var i = start;\n\n    while (content_height < viewport_height && i < items.length) {\n      var row = rows[i - start];\n\n      if (!row) {\n        end = i + 1;\n        yield tick(); // render the newly visible row\n\n        row = rows[i - start];\n      }\n\n      var row_height = height_map[i] = itemHeight || row.offsetHeight;\n      content_height += row_height;\n      i += 1;\n    }\n\n    end = i;\n    var remaining = items.length - end;\n    average_height = (top + content_height) / end;\n    bottom = remaining * average_height;\n    height_map.length = items.length;\n  });\n  return _refresh.apply(this, arguments);\n}\n\nfunction handle_scroll() {\n  return _handle_scroll.apply(this, arguments);\n} // trigger initial refresh\n\n\nfunction _handle_scroll() {\n  _handle_scroll = _asyncToGenerator(function* () {\n    var {\n      scrollTop\n    } = viewport;\n    var old_start = start;\n\n    for (var v = 0; v < rows.length; v += 1) {\n      height_map[start + v] = itemHeight || rows[v].offsetHeight;\n    }\n\n    var i = 0;\n    var y = 0;\n\n    while (i < items.length) {\n      var row_height = height_map[i] || average_height;\n\n      if (y + row_height > scrollTop) {\n        start = i;\n        top = y;\n        break;\n      }\n\n      y += row_height;\n      i += 1;\n    }\n\n    while (i < items.length) {\n      y += height_map[i] || average_height;\n      i += 1;\n      if (y > scrollTop + viewport_height) break;\n    }\n\n    end = i;\n    var remaining = items.length - end;\n    average_height = y / end;\n\n    while (i < items.length) {\n      height_map[i++] = average_height;\n    }\n\n    bottom = remaining * average_height; // prevent jumping if we scrolled up into unknown territory\n\n    if (start < old_start) {\n      yield tick();\n      var expected_height = 0;\n      var actual_height = 0;\n\n      for (var _i = start; _i < old_start; _i += 1) {\n        if (rows[_i - start]) {\n          expected_height += height_map[_i];\n          actual_height += itemHeight || rows[_i - start].offsetHeight;\n        }\n      }\n\n      var d = actual_height - expected_height;\n      viewport.scrollTo(0, scrollTop + d);\n    } // TODO if we overestimated the space these\n    // rows would occupy we may need to add some\n    // more. maybe we can just call handle_scroll again?\n\n  });\n  return _handle_scroll.apply(this, arguments);\n}\n\nonMount(() => {\n  rows = contents.getElementsByTagName('svelte-virtual-list-row');\n  mounted = true;\n});</script>\n\n<style>\n\tsvelte-virtual-list-viewport {\n\t\tposition: relative;\n\t\toverflow-y: auto;\n\t\t-webkit-overflow-scrolling:touch;\n\t\tdisplay: block;\n\t}\n\n\tsvelte-virtual-list-contents, svelte-virtual-list-row {\n\t\tdisplay: block;\n\t}\n\n\tsvelte-virtual-list-row {\n\t\toverflow: hidden;\n\t}\n</style>\n\n<svelte-virtual-list-viewport\n\tbind:this={viewport}\n\tbind:offsetHeight={viewport_height}\n\ton:scroll={handle_scroll}\n\tstyle=\"height: {height};\"\n>\n\t<svelte-virtual-list-contents\n\t\tbind:this={contents}\n\t\tstyle=\"padding-top: {top}px; padding-bottom: {bottom}px;\"\n\t>\n\t\t{#each visible as row (row.index)}\n\t\t\t<svelte-virtual-list-row>\n\t\t\t\t<slot item={row.data}>Missing template</slot>\n\t\t\t</svelte-virtual-list-row>\n\t\t{/each}\n\t</svelte-virtual-list-contents>\n</svelte-virtual-list-viewport>\n",
    "<script>export var size = 25;\nexport var speed = 750;\nexport var color = \"rgba(0,0,0,0.4)\";\nexport var thickness = 2;\nexport var gap = 40;\nexport var radius = 10;\nvar dash;\n\n$: dash = 2 * Math.PI * radius * (100 - gap) / 100;</script>\n\n<style>\n  .svelte-spinner {\n    transition-property: transform;\n    animation-name: svelte-spinner_infinite-spin;\n    animation-iteration-count: infinite;\n    animation-timing-function: linear;\n  }\n  @keyframes svelte-spinner_infinite-spin {\n    from {\n      transform: rotate(0deg);\n    }\n    to {\n      transform: rotate(360deg);\n    }\n  }\n</style>\n\n<!-- Ty EmilTholin for creating a high quality open source spinner -->\n<!-- https://github.com/EmilTholin/svelte-spinner/blob/master/src/index.svelte -->\n<svg height={size} width={size} style=\"animation-duration:{speed}ms;\" class=\"svelte-spinner\" viewbox=\"0 0 32 32\">\n  <circle\n    role=\"presentation\"\n    cx=\"16\"\n    cy=\"16\"\n    r={radius}\n    stroke={color}\n    fill=\"none\"\n    stroke-width={thickness}\n    stroke-dasharray=\"{dash},100\"\n    stroke-linecap=\"round\" />\n</svg>\n"
  ],
  "names": [],
  "mappings": "AAqJC,4BAA4B,eAAC,CAAC,AAC7B,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,IAAI,CAChB,2BAA2B,KAAK,CAChC,OAAO,CAAE,KAAK,AACf,CAAC,AAED,2CAA4B,CAAE,uBAAuB,eAAC,CAAC,AACtD,OAAO,CAAE,KAAK,AACf,CAAC,AAED,uBAAuB,eAAC,CAAC,AACxB,QAAQ,CAAE,MAAM,AACjB,CAAC;ACvJA,eAAe,cAAC,CAAC,AACf,mBAAmB,CAAE,SAAS,CAC9B,cAAc,CAAE,0CAA4B,CAC5C,yBAAyB,CAAE,QAAQ,CACnC,yBAAyB,CAAE,MAAM,AACnC,CAAC,AACD,WAAW,0CAA6B,CAAC,AACvC,IAAI,AAAC,CAAC,AACJ,SAAS,CAAE,OAAO,IAAI,CAAC,AACzB,CAAC,AACD,EAAE,AAAC,CAAC,AACF,SAAS,CAAE,OAAO,MAAM,CAAC,AAC3B,CAAC,AACH,CAAC"
}